{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Advances in machine learning techniques have resulted in the development of a type of deep learning model called a Large Language Model (LLM). Trained on a massive body of input, LLMs can generate plausible output in a variety of modalities given a prompt. One potential use case of LLMs is in generating Python code for solving geospatial problems. But the current state-of-the-art technology is still not capable of working fully autonomously. While substantial improvements have been made in the recent past, and will likely continue to be made in the future, there is a good chance that these models will always require at least some human intervention in order to output viable code. </p> <p>Consequently, the best way to approach these models is not as something that can replace humans, but as an additional tool to help humans work faster and more efficiently. This workshop will introduce the fundamental skills that people will need in order to make effective use of generative AI models.  LLMs are very good at some things. They typically create Python code in the appropriate syntax and can correctly summarize chunks of code. This means that when working with an AI code assistant, it is no longer as important to spend time learning the details of Python syntax. But there are some skills that are still important for people to cultivate. These skills include:</p> <ul> <li>Recognizing Python language features. You need to know enough about the Python language to recognize generally what generated code is doing. </li> <li>Function design. You need to know how to design functions in a way that serves as an effective prompt for the model. </li> <li>Prompt engineering. You need to know how to change prompts to iterate on the model-generated output. </li> <li>Problem decomposition. You need to know how to break big problems down into small problems that the model can more easily solve.</li> </ul> <p>The theoretical framework for this workshop is taken from Leo Porter and Daniel Zingaro\u2019s 2023 book Learn AI-Assisted Python Programming with GitHub Copilot and ChatGPT. That book is an excellent reference with additional depth beyond what can be covered here. This workshop will explore the strategies outlined in the book in the specific context of writing Python code to solve geospatial problems. That specific context will be important because, as we will see, LLMs have a poor understanding of GIS workflows. Your domain expertise will be necessary in order to get the most out of working with these models.</p>"},{"location":"FunctionDesign/","title":"Function Design","text":"<p>One way to work effectively with an AI code assistant is to write code that defines and uses functions. As you will see later, that makes it easier to break a large problem into more manageable pieces. Generally, you the human will design the function, and the model will use that design as a prompt to generate code. There are some guidelines you should follow when designing functions so that the model is more likely to generate usable code.</p>"},{"location":"FunctionDesign/#clearly-define-the-task","title":"Clearly define the task","text":"<p>A single function should perform a single job. You should be able to come up with a relatively short function name that clearly summarizes what that job is. The function name is part of what the LLM will use to help it understand what kind of code to generate, so you want it to be as specific as possible. If you can't come up with such a name, chances are pretty good that your function is trying to do too much.</p> <p>Imagine you had a csv with the lat/lon for point locations, and needed to be able to put a buffer around each point. You wrote this function definition to prompt the model: <pre><code>def make_areas(csv, distance):\n</code></pre> This definition is bad because the name is too vague. It would be better to have a name that more clearly indicates what the function should do:</p> <pre><code>def buffer(csv, distance):\n</code></pre>"},{"location":"FunctionDesign/#limit-input-parameters","title":"Limit input parameters","text":"<p>In the function definition, the input parameters are the names you put inside the parentheses. These names represent values that are used in the function. Generally, a small number of parameters (four or less) will help the model generate better code. Giving these parameters good names that describe what the values represent will also help. The function name and parameters are together called the function signature.</p> <p>Imagine you had a feature class that was in the wrong projection and you needed fix it. You wrote this function definition to prompt the model: <pre><code>def reproject_featureclass(featureclass, datum, spheroid, authority, primem, unit):\n</code></pre> This code is bad because it has too many parameters. You could improve the function by combining the spatial reference details into a single parameter:</p> <p><pre><code>def reproject_featureclass(featureclass, sr):\n</code></pre> There may need to be some other function to create the spatial reference. But creating multiple functions is preferable to having too many parameters in a single function.</p>"},{"location":"FunctionDesign/#add-a-doc-string","title":"Add a doc string","text":"<p>A doc string provides additional specific details about what the function does and how it should work. This doc string is also part of the prompt the LLM will use to generate code. The doc string may define what the input parameters represent, what the expected output is, details about what the function should (or should not) do, or any other information that describes the function more fully than can be done by the name alone. Taken together, the function definition and doc string will look something like:</p> <pre><code>def reproject_featureclass(featureclass, sr):\n\u00a0 \u00a0 \"\"\"\n\u00a0 \u00a0 featureclass: file path to a feature class\n\u00a0 \u00a0 sr: integer EPSG number\n\u00a0 \u00a0 Reproject the feature class into the new sr\n\u00a0 \u00a0 \"\"\"\n</code></pre>"},{"location":"FunctionDesign/#evaluate-model-output","title":"Evaluate model output","text":"<p>Based on your function design, you can have the model generate the code that does what the function is supposed to do. You will need to check the model\u2019s work, because chances are good that the generated code will not be correct. Some things to look out for:</p> <ul> <li>Function length. If the body of the function is more than about 20 lines of code, that is good evidence the model is trying to do too much. It also increases the possibility that there\u2019s a mistake somewheres</li> <li>Output value. Check the value returned by the function. Is that what the function should produce?</li> <li>Code you don\u2019t understand. This code may or may not be correct. If you don\u2019t understand it, you can\u2019t evaluate it. You can use the model itself to explain the code or run it by a trusted person.</li> </ul> <p>If the generated output seems problematic, adjust your function name, parameters, and doc string to help the model produce a better response. We\u2019ll talk more in the next section about prompt engineering so you can do this more effectively.</p> <p>If the generated output seems reasonable, try a few test cases to see if you get the result you expect. If it works correctly, you\u2019ve got a successful result! If not, you can go back and adjust your function design to get a working result from the model.</p>"},{"location":"FunctionDesign/#basic-function-design-cycle","title":"Basic function design cycle","text":"<p>The function design cycle is the iterative process of moving from function design to model output evalutation back to function design until you get a satisfactory result. </p> Adapted from Porter &amp; Zingaro, 2023"},{"location":"FunctionDesign/#exercise-design-a-function","title":"Exercise: Design a function","text":"<ol> <li>In an editor of your choice, write a function signature and doc string</li> <li>If you have access to an LLM:<ol> <li>Prompt the model to generate the function body</li> <li>Test the generated code to see the results</li> <li>Change the function design and re-prompt if needed</li> </ol> </li> <li>If you do not have access to an LLM:<ol> <li>Write additional function signatures and doc strings</li> </ol> </li> </ol>"},{"location":"ProblemDecomposition/","title":"Problem Decomposition","text":"<p>If you give an LLM a big problem and ask for a solution, chances are that it will fail to provide a reasonable response. As you have seen, they perform much better on narrower, more specific tasks. That\u2019s especially true for GIS workflows. Because geospatial problems are a relatively niche topic, LLMs don\u2019t have a robust training set from which they can generate coherent responses to questions about them. The models tend to do things like recommend raster data management tools for vector data. </p> <p>But sometimes we have a big problem, and we need a sophisticated solution. Fortunately, you can leverage your GIS expertise to help you break down a complex task into pieces small enough for the model to handle. </p>"},{"location":"ProblemDecomposition/#top-down-design","title":"Top-down design","text":"<p>Imagine you had to identify areas for habitat conservation and started with a single big function definition like this:</p> <pre><code>def habitat_conservation(datasets):\n    \"\"\"\n    Given the appropriate datasets, extract habitat locations for conservation\n    \"\"\"\n</code></pre> <p>The model will probably not be able to create appropriate code for this function. You need to decompose this problem into its constituent elements so that the model can reasonably provide an answer. This process of taking a big problem and breaking it down into pieces is called top-down design. For example, maybe you decide that the highest priority for conservation are habitats of threatened and endangered species that are within 2,000 meters of highways and not already inside existing conservation easements.</p> <p>You might design a few different functions to fulfill these subtasks:</p> <pre><code>def get_highways(roads):\n    \"\"\"\n    Given a feature class of roads, extract highway features\n    \"\"\"\n\ndef buffer_highways(highways):\n    \"\"\"\n    Given a set of highway features, create a 2000 meter buffer around them\n    \"\"\"\n\ndef priority_habitats(habitats):\n    \"\"\"\n    Given a feature class of habitats, \n    extract habitats for threatened or endangered species\n    \"\"\"\n</code></pre> <p>The model is much more likely to be able to provide solutions for these three narrower functions. And once you have working code for these sub-tasks, you can define a better function that puts all the pieces together. For example:</p> <pre><code>def habitat_conservation(roads, habitats, easements):\n    \"\"\"\n    Given feature classes for roads, habitats, and conservation easements,\n    identify habitats for threatened or endangered species \n    that are within 2000 meters of a highway\n    and not within an existing easement\n    \"\"\"\n</code></pre> <p>Because the model now knows how to identify highways, buffer those highways, and extract the priority habitats, it can use those functions inside the larger <code>habitat_conservation</code> function that solves the entire task.</p>"},{"location":"ProblemDecomposition/#full-function-design-cycle","title":"Full function design cycle","text":"<p>Problem decomposition means that if the model isn\u2019t providing you with usable code, you can improve your results by breaking a complex function down into its constituent parts. You can repeat this process, decomposing the problem into successively smaller pieces until you get a result that works.</p> Adapted from Porter &amp; Zingaro, 2023"},{"location":"ProblemDecomposition/#exercise-decompose-a-problem","title":"Exercise: Decompose a problem","text":"<p>Given this too-big function:</p> <pre><code>def update_feature_class(csv):\n    \"\"\"\n    Given a CSV file of addresses and other attributes, \n    update the appropriate existing point feature class\n    adding new features as needed.\n    \"\"\"\n</code></pre> <p>Design a few other functions to perform the necessary subtasks</p>"},{"location":"PromptEngineering/","title":"Prompt Engineering","text":"<p>Prompt engineering is the official name for \u201cmessing around with the function design until the model gives us a result we like\u201d. Effective prompt engineering is a vital skill for working with LLMs, just like using effective keyword terms is a vital skill for working with search engines. You will want to get a feel for what types of function designs are more likely to give you the results you want. And when you get results you don\u2019t like, you want to be able to understand what kinds of changes are likely to work. Developing these intuitions takes practice, and involves as much art as science, but there are some specific prompt engineering strategies you can employ to increase the chances of success.</p>"},{"location":"PromptEngineering/#have-the-model-suggest-changes","title":"Have the model suggest changes","text":"<p>Most models maintain sufficient context that they know what responses they have already provided. That means it is generally possible to interact with the model and have it provide fixes based on problems you have identified. </p> <p>For example, the Copilot extension for VS Code can provide alternatives to a selected code snippet with the <code>ctrl+enter</code> shortcut. If the Copilot Chat extension is installed, you can use the <code>fix</code> command to have Copilot suggest improvements to a snippet of code. These suggestions and fixes do not have to be on code generated by the model. You can have it suggest fixes for code you wrote yourself as well.</p>"},{"location":"PromptEngineering/#iterate-on-the-prompt","title":"Iterate on the prompt","text":"<p>If the model is not able to provide any helpful alternatives, it may be that the function design doesn\u2019t have the right type of information to effectively prompt the model. There are a couple of iteration strategies that can be helpful:</p> <ul> <li>Add specificity. This might mean making the function name less generic, or it might mean adding details to the doc string. For example, the function name <code>geojson_extent</code> is more specific than <code>parse_geojson</code>.</li> <li>Add constraints. Sometimes, the model will suggest code that incorporates an inappropriate element. For example, it may create a new feature class when the function should modify a feature class in place. You might get better results by specifying in the doc string that the function should not create a new feature class.</li> <li>Narrow scope. The generated code may be bad because you\u2019re asking the function to do too much. For example, a function to get the extent of geojson features may not successfully handle a file with multiple geometry types. Reducing the scope to just a single geometry type may produce better results: <code>point_geojson_extent</code> instead of <code>geojson_extent</code>.</li> </ul>"},{"location":"PromptEngineering/#add-tests","title":"Add tests","text":"<p>Another strategy for providing better prompting is to add automatic testing. The Python standard library has a module called <code>doctest</code> that lets you write tests in the doc string. When the code is executed, those tests are run as well. The module will tell you whether the code produced the expected results. Because the tests are in the doc string, they also help the model write code that is more likely to pass the tests.</p> <p>When writing these tests, create several different tests to check different types of inputs. Just because the function correctly handles one situation does not mean it correctly handles every situation. In particular, think about potential cases where an input might be a problem. For example, does the function correctly handle inputs on the edge of the dataset? Or with very large or very small values? If a function is expecting polygon data, what should happen if the input is point geometry? Sometimes a function should raise an exception, and you can even write a test that ensures the correct error message is raised for a given bad input.</p> <p>These tests look like code that calls the function and shows the expected output of that function. For example:</p> <pre><code>def county_neighbors(county):\n    \"\"\"\n    county: name of a Minnesota county\n    Return all bordering Minnesota counties \n    Sorted alphabetically\n\n    &gt;&gt;&gt; county_neighbors('Rock')\n    ['Murray', 'Nobles', 'Pipestone]\n\n    &gt;&gt;&gt; county_neighbors('Kanabec')\n    ['Aitkin', 'Chisago', 'Isanti', 'Mille Lacs', 'Pine']\n\n    &gt;&gt;&gt; county_neighbors('St. Croix')\n    Traceback (most recent call last):\n    KeyError: 'St. Croix'\n\n    \"\"\"\n</code></pre> <p>In this case, the tests check three potentially problematic inputs. </p> <ul> <li>Rock County borders both Iowa and South Dakota, but should not return any counties outside Minnesota. </li> <li>Kanabec County should include Chisago County even though they only border at a single point. </li> <li>St. Croix is not the name of any county in Minnesota, and the function should return a <code>KeyError</code>. </li> </ul> <p>When you call the <code>doctest.testmod()</code> function in your code, doctest runs all the tests you defined and compares the actual values returned to the expected values. If they match, the test passes. The module will report how many tests passed, and the actual values returned for any failing tests. For example, a function that did not correctly check counties that border at a single point would return the following output showing that the Kanabec County test had failed.</p> <pre><code>doctest.testmod()\n**********************************************************************\nFile \"__main__\", line 7, in __main__.county_neighbors\nFailed example:\n    county_neighbors('Kanabec')\nExpected:\n    ['Aitkin', 'Chisago', 'Isanti', 'Mille Lacs', 'Pine']\nGot:\n    ['Aitkin', 'Isanti', 'Mille Lacs', 'Pine']\n**********************************************************************\n1 items had failures:\n   1 of   3 in __main__.county_neighbors\n***Test Failed*** 1 failures.\nTestResults(failed=1, attempted=3)\n</code></pre>"},{"location":"PromptEngineering/#add-prompt-engineering-to-the-function-design-cycle","title":"Add prompt engineering to the function design cycle","text":"<p>Prompt engineering lets you add some specificity to the function design cycle to handle those situations where you don\u2019t get the response you want:</p> Adapted from Porter &amp; Zingaro, 2023"},{"location":"PromptEngineering/#exercise-improve-a-function","title":"Exercise: Improve a function","text":"<p>Given this terrible function design:</p> <pre><code>def md(first, second):\n    \"\"\"\n    Calculate Manhattan distance.\n    \"\"\"\n</code></pre> <ol> <li>Improve:<ol> <li>Function name</li> <li>Parameter names</li> <li>Doc string description</li> </ol> </li> <li>Add tests to the doc string</li> </ol>"},{"location":"PromptEngineering/#the-role-of-human-code-generating-skill","title":"The role of human code-generating skill","text":"<p>If you\u2019re already a Python expert, you may wonder what benefit AI code generation has for you. After all, you can already write better code than it can. But using an AI to help generate code means you can write code faster.  Boilerplate code, boring conditional blocks, long dictionary definitions, and other tedious constructs can all be created much faster when the AI writes them for you. That frees you up to focus on higher-level thinking about the code. AI code generation doesn\u2019t mean your expertise is wasted. It just means you engage with the language differently.</p>"},{"location":"PromptEngineering/#add-manual-review-to-the-function-design-cycle","title":"Add manual review to the function design cycle","text":"<p>The more you know about Python, the more you can short circuit some of the function design process. If you can fix some of the problems in the generated code yourself, you don\u2019t have to re-write the prompt and try to get the model to fix it.</p> Adapted from Porter &amp; Zingaro, 2023"},{"location":"PythonLanguageFeatures/","title":"Python Language Features","text":"<p>While you do not need to know everything about Python syntax, you should know enough to recognize the particular language features that generated code is using.</p>"},{"location":"PythonLanguageFeatures/#modules","title":"Modules","text":"<p>One of the most important facets of Python is the ecosystem of modules that people have created to solve a diverse array of problems. You can import these modules into your code so that you don\u2019t have to write your own solution. Python\u2019s standard library has many modules for working with the most common types of problems. Other modules need to be downloaded and installed separately. If you have ArcGIS Pro installed, you already have Python environment with about 200 additional modules installed. </p> <p>You can import all the functionality of a module with a simple import statement, which will look something like:</p> <pre><code>import csv\n</code></pre> <p>You can also import just a part of a module\u2019s functionality by specifying those parts, which will look something like:</p> <pre><code>from arcgis import features\n</code></pre> <p>You can give a module an alias when you import it. Aliases make it easier to refer to a module, and look something like: <pre><code>import pandas as pd\n</code></pre></p> <p>You should be able to recognize what it means when the model produces code that imports a module. Because the capabilities of a model cannot be used unless the module is imported, you will also need to recognize when the model has created code that makes use of a module, but has not also written the appropriate import statement.</p>"},{"location":"PythonLanguageFeatures/#data-types","title":"Data types","text":"<p>Different types of values have different capabilities. For example, you can\u2019t multiply a piece of text by another piece of text. You should recognize the data types created by the model. The table below shows the most common general Python data types.</p> Data type Description Examples Integer Whole numbers <code>80</code>, <code>-2</code> Float Any numeric value <code>9.84</code>, <code>-1.0</code> Boolean Logical values <code>True</code>, <code>False</code> String A set of characters, generally representing text values. Enclosed in <code>\"</code> or <code>'</code> quotes. <code>\"string\"</code>, <code>'8'</code>, <code>\"False\"</code> List Mutable (changeable) ordered sequence of values. Enclosed in <code>[]</code> brackets <code>[1, 2, 3, 4, 5, 6]</code> Tuple Immutable (unchangeable) ordered sequence of values. Enclosed in <code>()</code> parentheses. <code>(1, 2, 3, 4, 5, 6)</code> Dictionary Collection of key: value pairs. Enclosed in <code>{}</code> braces. Keys are usually strings or numbers. Values can be anything. <code>{\"MN\": 1, \"WI\": 2}</code> <p>Lists, tuples, and dictionaries are containers for other values. Those values could be any other types, even other lists, tuples, or dictionaries. You can easily have a list of dictionaries, where each value in each dictionary is itself another list of dictionaries.</p>"},{"location":"PythonLanguageFeatures/#variables","title":"Variables","text":"<p>Some values, like a long list or heavily nested dictionary, are very complex and hard to work with directly. It can be convenient to give values a name and refer to that value by its name instead. These variable names can also imbue a value with meaning for anyone reading the code. A good name can help us understand better what the code is doing. Values are assigned to variable names using the assignment operator <code>=</code>. For example:</p> <pre><code>capital = \"Saint Paul\"\npopulation = 5717000\nis_wisconsin = False\n</code></pre>"},{"location":"PythonLanguageFeatures/#blocks","title":"Blocks","text":"<p>A block is a chunk of connected code that performs a task. You can recognize a block because the first line will end with a colon (:) and the rest of the block will be indented one level relative to the first line. It is possible to have blocks inside of blocks.</p>"},{"location":"PythonLanguageFeatures/#conditional-blocks","title":"Conditional blocks","text":"<p>Allow you to deal with branching logic in your code. Conditional statements check the truth value of a statement, and if it is true, execute the code in the rest of the block. You can recognize a conditional by the use of the <code>if</code>, <code>elif</code> (else if) and <code>else</code> keywords. Statements typically use the logical operators</p> Operator Meaning <code>&gt;</code> Greater than <code>&lt;</code> Less than <code>==</code> Equal to <code>&gt;=</code> Greater than or equal to <code>&lt;=</code> Less than or equal to <code>!=</code> Not equal to <p>For example:</p> <pre><code>if capital == \"Saint Paul\":\n    state = \"Minnesota\"\nelif capital == \"Madison\":\n    state = \"Wisconsin\"\nelse: \n    state = \"Unknown\"\n</code></pre> <p>This code snippet checks the value of <code>capital</code> against different possibilities. It first checks to see if the value is equal to <code>\"Saint Paul\"</code>. If so, it sets the value of <code>state</code> to <code>\"Minnesota\"</code>. If not, it checks to see if the value is equal to <code>\"Madison\"</code>. If so, it sets the value of <code>state</code> to <code>\"Wisconsin\"</code>. If <code>capital</code> is any other value, it sets the value of <code>state</code> to <code>\"Unknown\"</code>.</p>"},{"location":"PythonLanguageFeatures/#for-loops","title":"For loops","text":"<p>Allow for repeated code execution. You can recognize a for loop by the use of the <code>for</code> and <code>in</code> keywords. For example: </p> <pre><code>seq = (1, 2, 3, 4, 5, 6)\nbig_seq = []\nfor num in seq:\n    if num &gt; 4:\n        big_seq.append(num)\n</code></pre> <p>This code snippet starts with a tuple <code>seq</code> and an empty list <code>big_seq</code>. It looks at every value inside <code>seq</code> in order. If the value is bigger than 4, it appends that value to <code>big_seq</code>. After running this code, the value of <code>big_seq</code> will be <code>[5, 6]</code>. </p>"},{"location":"PythonLanguageFeatures/#functions","title":"Functions","text":"<p>Encapsulate some process so that the process can easily be repeated without having to write the code to perform that process again. Functions must be defined before they can be used. You can recognize a function definition by the use of the <code>def</code> keyword. A function will typically produce some value, specified by the <code>return</code> keyword. For example:</p> <pre><code>def dist(x1, y1, x2, y2):\n    a_sq = (x2 - x1)**2\n    b_sq = (y2 - y1)**2\n    return (a_sq + b_sq)**0.5\n</code></pre> <p>This code snippet creates a function that calculates the Euclidean distance between two points, given their x,y coordinates. It uses to Pythagorean formula: first it calculates the square of the difference between the two x-coordinates (the <code>a_sq</code> value), then it calculates the square of the difference between the two y-coordinates (the <code>b_sq</code> value). Then it returns the square root of the sum of those squared differences.</p> <p>After a function has been defined, it must be called in order to execute it. You can recognize a function is being called by the parentheses after its name. There may or may not be any values inside the parentheses. For example:</p> <pre><code>dist(0, 0, 1, 1)\n</code></pre> <p>This code snippet calls the <code>dist</code> function to find the distance between the point at coordinates 0,0 and the point at coordinates 1,1. It will return a value of approximately 1.41.</p>"},{"location":"PythonLanguageFeatures/#files","title":"Files","text":"<p>Sometimes the data we want to work with is stored outside the script, in files. You will need to open those files in order to work with the data inside them. You will recognize code that opens a file by the use of the <code>open</code> function, which specifies the file\u2019s path and a mode (<code>'r'</code> for read, <code>'w'</code> for overwrite, <code>'a'</code> for append). As a best practice, opening files should be done in a context manager block, which you can recognize by the use of the <code>with</code> and <code>as</code> keywords. For example:</p> <pre><code>text_file = r'C:\\temp\\text.txt'\nwith open(text_file, 'r') as f:\n    for line in f:\n        print(line)\n</code></pre> <p>This code snippet will open the file located at C:\\temp\\text.txt and open it for reading. The open file is stored in the <code>f</code> variable. It loops through every line in the file and prints out that line.</p> <p>Python can read text files, but some file types may require additional modules to read them correctly. For example, the <code>csv</code> module is helpful for reading csv files as tabular data. </p> <pre><code>import csv\ncsv_file = r'C:\\temp\\data.csv'\nwith open(csv_file, 'r') as f:\n\u00a0 \u00a0 for row in csv.reader(f):\n\u00a0 \u00a0 \u00a0 \u00a0 print(row)\n</code></pre> <p>This code works similarly to the code above, but reads a row of table values, instead of a line of text.</p>"},{"location":"PythonLanguageFeatures/#exercise-identify-programming-features","title":"Exercise: Identify programming features","text":"<ol> <li>Open the Python Feature Quiz in a new browser tab.</li> <li>Answer the questions about Python features until you either feel confident that you can recognize all the features or you get bored.</li> <li>Open the source code for the quiz in a new browser tab.</li> <li>Examine the code. Which features do you recognize? Which features do you not recognize?</li> </ol>"},{"location":"PythonLanguageFeatures/#have-the-model-summarize-code-features","title":"Have the model summarize code features","text":"<p>If you have access to an LLM interface, like Copilot or ChatGPT, you can have the model summarize a chunk of code that uses Python features you do not recognize. LLMs tend to be much better at summarizing content than they are at generating it themselves, and the summaries are typically reliable. You can have the model summarize the code it generated for you, or code snippets you have found elsewhere.</p>"},{"location":"Resources/","title":"Resources","text":"<p>If you\u2019re looking for additional information about the topics covered in these pages, you might consult these resources:</p> <ul> <li>Learn AI-Assisted Python Programming with GitHub Copilot and ChatGPT (manning.com)</li> <li>Decomposition, Abstraction, and Functions (mit.edu)</li> <li>Prompt engineering (openai.com)</li> <li>doctest \u2014 Test interactive Python examples (python.org)</li> <li>Python's doctest: Document and Test Your Code at Once (realpython.com)</li> <li>Style Decomposition (stanford.edu)</li> <li>ArcPy Essentials (esri.com)</li> <li>ArcGIS Pro geoprocessing tool reference (arcgis.com)</li> <li>API Reference for the ArcGIS API for Python (arcgis.com)</li> <li>PyQGIS Developer Cookbook (qgis.com)</li> <li>Open Source Spatial Programming &amp; Remote Sensing (pygis.io)</li> </ul>"}]}